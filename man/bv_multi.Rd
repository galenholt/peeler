% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bv_multi.R
\name{bv_multi}
\alias{bv_multi}
\title{Wrapper for \code{bvstep} to restart over random starts to avoid finding only
local optima.}
\usage{
bv_multi(
  ref_mat,
  comp_mat,
  ref_dist = "bray",
  comp_dist = "bray",
  rand_start = TRUE,
  nrand = round(ncol(ref_mat)/10),
  num_restarts = ifelse(rand_start, 5, 1),
  num_best_results = min(c(5, num_restarts)),
  ties.method = "random",
  force_include = NULL,
  force_exclude = NULL,
  rho_threshold = 0.95,
  min_delta_rho = 0.001,
  corr_method = "kendall",
  return_type = "final",
  returndf = TRUE,
  selection_ref = "name",
  parallel = TRUE
)
}
\arguments{
\item{ref_mat}{the reference ('fixed') matrix that gets considered in whole}

\item{comp_mat}{the 'variable' matrix that gets forward/backward chopped}

\item{ref_dist}{distance metric for \code{ref_mat} (see \code{method} in \code{\link[vegan:vegdist]{vegan::vegdist()}})}

\item{comp_dist}{distance metric for \code{comp_mat} (see \code{method} in \code{\link[vegan:vegdist]{vegan::vegdist()}})}

\item{rand_start}{logical, default \code{TRUE}.
\itemize{
\item \code{TRUE}, start with \code{nrand} randomly-selected columns from \code{comp_mat} (plus any in \code{force_include}). Useful with \code{\link[=bv_multi]{bv_multi()}} to avoid local optima.
\item \code{FALSE}, start with the best available single column of \code{comp_mat} if \code{force_include = NULL} or \code{force_include}.
}}

\item{nrand}{number of columns to choose for a random start. Defaults to 10\%. Should not be too large, or it is hard to drop uninformative. Only used if \code{rand_start = TRUE}}

\item{num_restarts}{number of times run the bvstep from random starts}

\item{num_best_results}{how many of the outputs to return. Runs are sorted
from highest to lowest correlation, and the top \code{num_best_results} are
returned, with ties determined by \code{ties.method}}

\item{ties.method}{Argument passed to \code{\link[base:rank]{base::rank()}}: how to handle ties
between runs when sorting by highest correlation. Default \code{random} just
chooses tied runs at random, and so if ties cross the threshold of
\code{num_best_results}, the output will have \code{num_best_results} runs in it, but
there may be others with the same stopping correlation. The other logical
choice is \code{min}, ties are given the minimum value. This will return \emph{at
least} \code{num_best_results} runs, but may return more if ties cross that
boundary.}

\item{force_include}{\code{NULL} (default) or character of columns to always include- these are there at the start and never get dropped. If \code{rand_start = TRUE}, random columns are in addition to these.}

\item{force_exclude}{\code{NULL} (default) or character of columns to always exclude- these are just dropped right at the start.}

\item{rho_threshold}{Default 0.95. Threshold at which to cut off the process. If this is crossed at a forward step, one last backward step is taken to check if a smaller set still meets the condition.}

\item{min_delta_rho}{Default 0.001. Cutoff to stop the process if rho is not increasing much.}

\item{corr_method}{character, default \code{kendall}. This is the \code{method} argument of \code{\link[=cor]{cor()}}. Clarke and Warwick 1998 suggests kendall because we need a rank correlation and spearman doesn't handle ties.}

\item{return_type}{character, defines how much to return
\itemize{
\item \code{'final'}: default, returns the final outcome of the best \code{num_best_results} random starts
\item \code{'steps'}: returns the full set of forward/backward steps for the best \code{num_best_results} random starts
\item \code{'unique'}: returns the best \code{num_best_results} best selections out of all steps of all random starts. The first entry should be the same as in \code{'final'}, but after that they may not be, if the penultimate selection in some sets are better than the final selection in others
}}

\item{returndf}{logical, default \code{TRUE}, only relevant if \verb{return_type = 'steps}
\itemize{
\item \code{TRUE}: return a dataframe as in \code{\link[=bvstep]{bvstep()}} with an additional column indicating which iterations are returned.
\item \code{FALSE}: return a list, with each element a dataframe as returned by \code{\link[=bvstep]{bvstep()}}
}}

\item{selection_ref}{character, \code{'name'} (default)- return the variable names in each step. \code{'index'} returns their column index in \code{comp_mat}}

\item{parallel}{logical, default TRUE. Parallelise over num_restarts using \code{\link[furrr:future_map]{furrr::future_map()}}. Need to have {furrr} installed and have set a \code{\link[future:plan]{future::plan()}}. See the help for {furrr} or {future}.}
}
\value{
dataframe (typically) or list (if \code{return_type == 'steps'} and
\code{returndf = FALSE}), of the best \code{num_best_results}, sorted by number of
species if correlation is over \code{rho_threshold}, and then highest
correlations. The \code{num_tied_with} column indicates how many results had the
same num_vars and correlation
}
\description{
Runs \code{\link[=bvstep]{bvstep()}} a number of times with random starts, sorts the outcomes by
correlation, and returns the best \code{num_best_results} as either a list or
dataframe. This uses {furrr} if it is installed, and so allows the user to
run each set of randon starts in parallel by setting a \verb{[future::plan()]},
e.g. \code{plan(multisession)} before running this code.
}
\examples{
require(vegan)
data(varespec)
bvout <- bv_multi(
  ref_mat = varespec, comp_mat = varespec,
  ref_dist = "bray", comp_dist = "bray",
  rand_start = TRUE, nrand = 5, num_restarts = 10
)

}
