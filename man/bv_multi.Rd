% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bv_multi.R
\name{bv_multi}
\alias{bv_multi}
\title{Wrapper for \code{bvstep} to restart over random starts to avoid finding only
local optima.}
\usage{
bv_multi(
  ref_mat,
  comp_mat,
  ref_dist = "bray",
  comp_dist = "bray",
  rand_start = TRUE,
  nrand = round(ncol(ref_mat)/10),
  num_restarts = ifelse(rand_start, 5, 1),
  num_best_results = min(c(5, num_restarts)),
  ties.method = "random",
  force_include = NULL,
  force_exclude = NULL,
  rho_threshold = 0.95,
  min_delta_rho = 0.001,
  corr_method = "kendall",
  returndf = TRUE,
  selection_ref = "name"
)
}
\arguments{
\item{ref_mat}{the reference ('fixed') matrix that gets considered in whole}

\item{comp_mat}{the 'variable' matrix that gets forward/backward chopped}

\item{ref_dist}{distance metric for \code{ref_mat} (see \code{method} in \code{\link[vegan:vegdist]{vegan::vegdist()}})}

\item{comp_dist}{distance metric for \code{comp_mat} (see \code{method} in \code{\link[vegan:vegdist]{vegan::vegdist()}})}

\item{rand_start}{logical, default \code{TRUE}.
\itemize{
\item \code{TRUE}, start with \code{nrand} randomly-selected columns from \code{comp_mat} (plus any in \code{force_include}). Useful with \code{\link[=bv_multi]{bv_multi()}} to avoid local optima.
\item \code{FALSE}, start with the best available single column of \code{comp_mat} if \code{force_include = NULL} or \code{force_include}.
}}

\item{nrand}{number of columns to choose for a random start. Defaults to 10\%. Should not be too large, or it is hard to drop uninformative. Only used if \code{rand_start = TRUE}}

\item{num_restarts}{number of times run the bvstep from random starts}

\item{num_best_results}{how many of the outputs to return. Runs are sorted
from highest to lowest correlation, and the top \code{num_best_results} are
returned, with ties determined by \code{ties.method}}

\item{ties.method}{Argument passed to \code{\link[base:rank]{base::rank()}}: how to handle ties
between runs when sorting by highest correlation. Default \code{random} just
chooses tied runs at random, and so if ties cross the threshold of
\code{num_best_results}, the output will have \code{num_best_results} runs in it, but
there may be others with the same stopping correlation. The other logical
choice is \code{min}, ties are given the minimum value. This will return \emph{at
least} \code{num_best_results} runs, but may return more if ties cross that
boundary.}

\item{force_include}{\code{NULL} (default) or character of columns to always include- these are there at the start and never get dropped. If \code{rand_start = TRUE}, random columns are in addition to these.}

\item{force_exclude}{\code{NULL} (default) or character of columns to always exclude- these are just dropped right at the start.}

\item{rho_threshold}{Default 0.95. Threshold at which to cut off the process. If this is crossed at a forward step, one last backward step is taken to check if a smaller set still meets the condition.}

\item{min_delta_rho}{Default 0.001. Cutoff to stop the process if rho is not increasing much.}

\item{corr_method}{character, default \code{kendall}. This is the \code{method} argument of \code{\link[=cor]{cor()}}. Clarke and Warwick 1998 suggests kendall because we need a rank correlation and spearman doesn't handle ties.}

\item{returndf}{logical, default \code{TRUE}-
\itemize{
\item \code{TRUE}: return a dataframe as in \code{\link[=bvstep]{bvstep()}} with an additional column indicating which iterations are returned.
\item \code{FALSE}: return a list, with each element a dataframe as returned by \code{\link[=bvstep]{bvstep()}}
}}

\item{selection_ref}{character, \code{'name'} (default)- return the variable names in each step. \code{'index'} returns their column index in \code{comp_mat}}
}
\value{
dataframe or list, as determined by \code{returndf}, of the best
\code{num_best_results}, sorted by highest correlations.
}
\description{
Runs \code{\link[=bvstep]{bvstep()}} a number of times with random starts, sorts the outcomes by
correlation, and returns the best \code{num_best_results} as either a list or
dataframe. This uses {furrr} if it is installed, and so allows the user to
run each set of randon starts in parallel by setting a \verb{[future::plan()]}, e.g.
\code{plan(multisession)} before running this code.
}
